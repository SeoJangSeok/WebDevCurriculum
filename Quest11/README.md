# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- RDBMS 테이블의 정규화는 무엇인가요?

  ```
  RDBMS : 관계형 데이터베이스는 서로 관련된 데이터 지점에 대한 접근을 저장 및 제공하는 데이터베이스 유형이다. 관계형 데이터베이스는 데이터를 테이블에 직관적으로 간단하게 나타내는 관계형 모델을 기반으로 한다. 관계형 데이터베이스에서 테이블의 각 행은 키라는 고유 ID가 포함된 레코드이다. 테이블의 열에는 데이터의 속성이 들어 있으며, 각 레코드에는 일반적으로 각 속성에 대한 값이 있으므로 데이터 포인트 간의 관계를 손쉽게 설정할 수 있다.

  정규화 : DB를 설계할 때, 중복을 최소화하면서 데이터 구조를 짜는 프로세스이다.
  ```

- MySQL 외의 RDB에는 어떤 것들이 있나요?
  ```
  1. Oracle
  2. Microsoft SQL Server
  3. My SQL
  4. DB2
  5. Sybase
  6. Informix
  7. MS Access etc...
  ```
  - Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?
    ```
    HDBMS(계층형 데이터베이스) : 폴더와 파일 등의 계층 구조로 데이터를 저장하는 방식 - 데이터의 관계를 트리 구조로 정의, 부모-자식 형태를 가짐.
    NDBMS(네트워크형 데이터베이스) : 데이터 구조를 네트워크상의 노드 형태로 논리적이게 표현한 데이터 모델, 각각의 노드를 서로 대등한 관계로 구성한 시스템이다.
    ```
- RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?
  ```
  Index는 RDBMS(관계형 데이터베이스 관리 시스템)에서 테이블에 대한 검색 속도를 높여주는 자료 구조를 말하며, 테이블 내에 1개의 컬럼 혹은 여러 개의 컬럼을 이용하여 생성한다.
  특정 테이블의 컬럼을 인덱싱(Indexing)하면 검색을 할 때 테이블의 레코드를 전부 다 확인하는 것이 아니라 인덱싱 되어있는 자료 구조를 통해서 검색되기 때문에 검색 속도가 빨라지는 것이다.
  인덱스가 생성되었다면, SELECT 쿼리문에서 'Index 생성 컬럼을 WHERE 조건으로 걸거나', 'Index 컬럼으로 OrderBy에 의한 Sort를 적용하는' 등의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 적용하여 SELECT문이 실행된다.
  ```
- ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?

  ```
  ORM(Object Relational Mapping) : 객체-관계 매핑의 줄임말이다. 객체-관계 매핑을 풀어서 설명하자면 우리가 OOP(Object Oriented Programming)에서 쓰이는 객체라는 개념을 구현한 클래스와 RDB(Relational DataBase)에서 쓰이는 데이터인 테이블 자동으로 매핑(연결)하는 것을 의미한다. 그러나 클래스와 테이블은 서로가 기존부터 호환가능성을 두고 만들어진 것이 아니기 때문에 불일치가 발생하는데, 이를 ORM을 통해 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하여 불일치를 해결한다. 따라서 ORM을 이용하면 따로 SQL문을 짤 필요없이 객체를 통해 간접적으로 데이터베이스를 조작할 수 있게 된다.

  장점
  - 완벽한 객체지향적인 코드 : ORM을 이용하면 SQL문이 아닌 클래스의 메서드를 통해 데이터베이스를 조작할 수 있어, 개발자가 객체 모델만 이용해서 프로그래밍을 하는 데 집중할 수 있게한다. SQL 문을 사용하면서 같이 필요한 선언문, 할당, 종료 같은 부수적인 코드가 사라지거나 줄어들며, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높일 수 있다. 객체지향적 접근과 SQL의 절차적/순차적 접근이 혼재되어있던 기존 방식과 달리 오직 객체지향적 접근만 고려하면 되기때문에 생산성이 증가한다.
  - 재사용, 유지보수, 리팩토링 용이성 : ORM은 기존 객체와 독립적으로 작성되어있고, 객체로 작성되었기 때문에 재활용할 수 있다. 또한, 매핑하는 정보가 명확하기 때문에 ERD를 보는 의존도를 낮출 수 있다.
  - DBMS(DataBase Management System) 종속성 하락 : 객체 간의 관계를 바탕으로 SQL문을 자동으로 생성하고, 객체의 자료형 타입까지 사용할 수 있기 때문에 RDBMS의 데이터 구조와 객체지향 모델 사이의 간격을 좁힐 수 있다. 객체에만 집중할 수 있기 때문에 DBMS를 교체하는 큰 작업에도 리스크가 적고 드는 시간도 줄어든다. 예들 들어 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠르게 가공할 수 있다.

  단점
  - ORM이 모든 걸 해결해줄 수 없다 : 적절하게 SQL문을 사용할 수 있어야한다.
  프로젝트의 복잡성이 커질 수록 난이도도 올라가고 부족한 설계로 잘못 구현되었을 경우 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다. 또한 일부 자주 사용되는 대형 SQL문은 속도를 위해 별도의 튜닝이 필요하기 때문에 결국 SQL문을 써야할 수도 있다.
  - 복잡한 쿼리문의 경우 오히려 SQL문으로 사용이 직관적이면서 효율적일 수 있다.
  ```

  - 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?
    ```
    대표적으로 sequelize가 있고, postgreSQL과 같은 관계형데이터베이스와 많이 연동하여 사용한다.
    ```

- 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?

  ```
  1:1 관계 : 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우이다.
  ex)  Users 테이블과 Phonebook 테이블이 있다고 가정한다.
  Users 테이블은 ID, name, phone_id를 가지고 있다.
  이 중 phone_id는 외래키(foreign key)로써, Phonebook 테이블의 ID 와 연결되어 있다.
  Phonebook 테이블은 ID와 phone_number를 가지고 있다.
  각 전화번호가 단 한 명의 유저와 연결되어 있고, 그 반대도 동일하다면, Users 테이블과 Phonebook 테이블은 1:1 관계(One-to-one relationship)이다.

  1:N 관계 : 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우이다.
  예) Users 테이블과 Phonebook 테이블의 관계를 다음과 같이 가정한다.
  이 구조에서는 한 명의 유저가 여러 전화번호를 가질 수 있다.
  그러나 여러명의 유저가 하나의 전화번호를 가질 수는 없다.
  이런 1:N(일대다) 관계는 관계형 데이터베이스에서 가장 많이 사용한다.

  N:M 관계 : 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우이다. N:M(다대다) 관계를 위해 스키마를 디자인할 때에는, Join 테이블을 만들어 관리한다.
  1:N(일대다) 관계와 비슷하지만, 양방향에서 다수의 레코드를 가질 수 있다.
  ```

- DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

  ```
  암호를 평문으로 저장한다면 보안에 문제가 된다. 따라서 해쉬 함수나 암호화 알고리즘을 통해서 저장한다.
  ```

  - 해시 함수에는 어떤 것이 있나요?

    ```
    MD4 와 MD5 :
    MD4 는 16단계의 3라운드를 사용하나 MD5 는 16단계의 4라운드를 사용한다.
    MD4 는 각 라운드에서 한 번씩 3개의 기약 함수를 사용한다. 그러나 MD5 는 각 라운드에서 한 번씩 4개의 기약 함수를 사용한다.
    MD4 는 마지막 단계의 부가를 포함하지만 MD5 의 각 단계는 이전 단계의 결과에 부가된다.

    SHA(Secure Hash Algorithm)은 NIST(National Institute of Standards and Technology)에서 만들어진, 160비트의 해시 값을 갖는 일방향 해시 함수이다. 1993년에 미국의 연방정보처리표준규격(FIPS PUB 180) 으로서 발표된 것을 SHA 라 부르며, 1995년에 발표된 개정판 FIPS PUB 180-1 을 SHA-1 이라 부른다. SHA-1 의 메시지의 길이에는 상한이 있지만, 264 비트 미만이라는 대단히 큰 값이므로 사실상 현실적인 적용에는 문제가 없다.

    2005년에 NIST 에서는 SHA-1 에 대한 승인을 취소한다고 선언했고 2010년까지 새로운 SHA 버전들로 대체한다고 했다. 하지만 이미 NIST 에서는 2002년에 NIST 는 새표준인 FIPS 180-2 를 내놓았는데 이때 해시 값이 각각 256, 384 와 512 비트인 3 개의 새로운 SHA 버전들을 정의했다. 이들은 각각 SHA-256, SHA-384 와 SHA-512 로 AES 의 키 길이인 128, 192, 256 비트에 대응하도록 출력 길이를 늘인 해시 알고리즘이다.
    ```

  - 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?
    ```
    단방향 해시 함수 ( One-Way Hash Function ) : 단방향 해시 함수는 어떤 수학적 연산(또는 알고리즘)에 의해 원본 데이터를 매핑시켜 완전히 다른 암호화된 데이터로 변환시키는 것을 의미한다. 이 변환을 해시라고 하고, 해시에 의해 암호화된 데이터를 다이제스트(digest)라고 한다. 비밀번호 123456을 해시함수에 돌려 다이제스트인 fs32a3xzz0 을 생성하고 해당 데이터를 DB 에 저장하는 것이다.
    솔트(salt) : 해시함수를 돌리기 전에 원문에 임의의 문자열을 덧붙이는 것을 말한다. 단어 뜻 그대로 원문에 임의의 문자열을 붙인다는 의미의 소금친다(salting) 는 것이다. 이렇게 하면 설령 다이제스트를 알아낸다 하더라도 password 를 알아내기 더욱 어려워진다. 그리고 사용자마다 다른 Salt 를 사용한다면 설령 같은 비밀번호더라도 다이제스트의 값은 다르다. 이는 결국 한 명의 패스워드가 유출되더라도 같은 비밀번호를 사용하는 다른 사용자는 비교적 안전하다는 의미이다.
    ```

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
